# PostgreSQL

# 개념

### 페이지

DB에서 I/O의 최소단위. PostgreSQL의 기본 페이지 크기는 8KB이다(빌드 시점에 변경 가능). 저장장치에서 데이터를 읽을 때는 필요한 레코드 하나만 읽을 수 없기에 항상 페이지 단위로 읽기 작업이 수행된다.

**왜 페이지 단위로 읽을까?**

디스크 I/O가 비싸기 때문이다. CPU 바운딩 작업보다 I/O 바운딩 작업에서 훨씬 큰 지연이 발생한다. 디스크 I/O 시에 작은 단위를 많이 읽는 것 보다 한 번에 페이지 단위로 읽는 게 지역성의 법칙에 부합한다.

비슷한 맥락에서 DBMS는 읽은 페이지를 Shared Buffer(DB 캐시)에 올려두고 재사용한다. 

또한 정렬/검색 시에 인덱스 노드 크기를 페이지 크기와 맞추면 한 번 읽을 때 수백~수천 개의 키를 가져와 탐색 깊이를 얕게 만들 수 있다. 

정리해서 페이지를 DB와 디스크 사이의 패킷같은 것이라고 생각하자. 네트워크에서 패킷 단위로 통신하듯, DB도 페이지 단위로 디스크와 통신한다.

### PostgreSQL의 페이지 구조

디폴트 8KB의 페이지는 크게 네 영역으로 구분된다.

1. Header (고정 길이)
    
    페이지 ID, checksum 등 관리 정보
    
2. Line Pointer Array (Slot Directory)
    
    각 튜플의 메모리상 저장 위치를 가리키는 포인터 배열
    
    튜플을 삭제해도 실제 메모리에서 바로 지우지 않고, 이 포인터만 “죽었다”고 표시한다.
    
3. Tuple Data Area
    
    실제 레코드(행 데이터) 저장 공간
    
    데이터를 삽입할 때는 아래쪽부터, 포인터는 위쪽부터 채워나간다.
    
4. Free Space
    
    아직 쓰이지 않은 영역
    

→ 단순화하면 한 페이지는 헤더, 포인터, 튜플 데이터로 구성된다.

## 디스크 → 메모리 → CPU로 어떻게 읽힐까?

1. 데이터가 8KB 페이지 단위로 물리 디스크에 저장됨
2. READ → 쿼리가 필요로 하는 페이지를 디스크에서 읽어 PostgreSQL의 **Shared Buffer(메모리)**에 올린다.
3. CPU에서 Shared Buffer에 있는 페이지를 탐색해 튜플에서 원하는 데이터를 찾는다.

→ SQL 실행 시 “이 쿼리가 몇 페이지를 읽을까?”를 계산하는 성능적 직관을 키우자.

## 페이지와 B-Tree

B-Tree의 노드 한 개는 DB 페이지 한 개에 대응되도록 설계됐다.

따라서 8KB의 페이지에 400개의 키를 담으면, 한 노드에서 400개의 분기를 가지게 된다.

트리 깊이 = log(분기 수)(총 데이터 수) → 트리 깊이가 아주 얕아진다.

→ 트리 깊이가 얕다는 건 곧 디스크 I/O 횟수가 적다는 것을 의미한다.

→ 대부분의 RDB가 B-Tree 기반으로 구현된 건 B-Tree가 위와 같은 방식으로 페이지에 최적화된 트리이기 때문이다. B-Tree는 단순한 트리가 아니라 “디스크 페이지 단위 I/O를 고려한 트리”다.

## 기억하기

- 개별 행에는 직접 접근할 수 없다. 반드시 페이지를 거친다.
- SQL 최적화는 그래서 **얼마나 페이지를 덜 읽을 수 있는가?**의 문제이다.
- Seq Scan은 테이블의 전체 페이지를 순차적으로 읽는다.
- Index Scan은 B-Tree에서 필요한 페이지 몇 개만 골라 읽는다.
- 캐싱과 병렬 처리도 결국 페이지 단위로 동작한다.
